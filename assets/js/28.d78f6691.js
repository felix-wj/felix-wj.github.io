(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{496:function(n,t,e){"use strict";e.r(t);var r=e(10),o=Object(r.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"synchronized与reentrantlock比较"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#synchronized与reentrantlock比较"}},[n._v("#")]),n._v(" synchronized与ReentrantLock比较")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("锁的实现\nsynchronized是JVM实现的，ReentrantLock是JDK实现的")])]),n._v(" "),t("li",[t("p",[n._v("性能\n新版本Java对synchronized做了优化，比如适应性自旋、锁偏向、轻量级锁，性能与ReentrantLock相当。")])]),n._v(" "),t("li",[t("p",[n._v("等待可中断\nReentrantLock可以设置获取锁的等待时间，synchronized不行。")])]),n._v(" "),t("li",[t("p",[n._v("锁绑定条件\nReentrantLock可以通过Condition绑定多个对象。")])]),n._v(" "),t("li",[t("p",[n._v("公平性\nsynchronized是非公平的，Reentrant可以设置公平还是非公平。")])])]),n._v(" "),t("p",[n._v("synchronized锁对象不能为空，因为锁信息记录在对象头中。")]),n._v(" "),t("p",[n._v("除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放")]),n._v(" "),t("h2",{attrs:{id:"jvm中锁的优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm中锁的优化"}},[n._v("#")]),n._v(" JVM中锁的优化")]),n._v(" "),t("p",[n._v("JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用Mutex Lock那么将严重的影响程序的性能。不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销。")]),n._v(" "),t("h2",{attrs:{id:"公平锁与非公平锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#公平锁与非公平锁"}},[n._v("#")]),n._v(" 公平锁与非公平锁")]),n._v(" "),t("p",[n._v("主要区别是，当线程发现可以抢占锁时，是立即抢占，还是进入等待队列，唤醒队首的线程。")]),n._v(" "),t("p",[n._v("非公平锁可以减少线程切换次数，提高性能。但是可能出现不断有新线程获取锁，老线程始终等待的“锁饥饿”情况。")])])}),[],!1,null,null,null);t.default=o.exports}}]);