(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{518:function(e,a,t){"use strict";t.r(a);var v=t(10),_=Object(v.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"可优化方向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可优化方向"}},[e._v("#")]),e._v(" 可优化方向")]),e._v(" "),a("h3",{attrs:{id:"调整g1的region大小"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调整g1的region大小"}},[e._v("#")]),e._v(" 调整G1的Region大小")]),e._v(" "),a("p",[e._v("默认情况下，G1 堆区域的大小并不是固定的数值，而是由 JVM 根据整个堆的大小动态计算的。JVM 会尝试将整个堆划分为大约 2048 个区域，这样的区域大小会在 1MB 到 32MB 之间取一个 2 的幂。\n通过"),a("code",[e._v("-XX:G1HeapRegionSize")]),e._v("设置，例如:"),a("code",[e._v("-XX:G1HeapRegionSize=16M")]),e._v("，可以调整"),a("code",[e._v("Region")]),e._v("的大小，一般建议设置为1M~32M之间，过大会导致"),a("code",[e._v("Region")]),e._v("数量减少，过小会导致"),a("code",[e._v("Region")]),e._v("数量增多，影响GC效率。")]),e._v(" "),a("p",[e._v("但一般自动调整可能更合适，除非有特殊需求。")]),e._v(" "),a("h3",{attrs:{id:"调整maxgcpausemillis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调整maxgcpausemillis"}},[e._v("#")]),e._v(" 调整MaxGCPauseMillis")]),e._v(" "),a("p",[e._v("默认是200ms，如果应用对延迟敏感，可以降低这个值，让G1更积极地回收，可能减少堆占用。")]),e._v(" "),a("p",[e._v("例如:"),a("code",[e._v("-XX:MaxGCPauseMillis=100")]),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"调整g1的ihop-initiatingheapoccupancypercent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调整g1的ihop-initiatingheapoccupancypercent"}},[e._v("#")]),e._v(" 调整"),a("code",[e._v("G1")]),e._v("的"),a("code",[e._v("IHOP（InitiatingHeapOccupancyPercent）")])]),e._v(" "),a("p",[e._v("即触发并发周期的堆占用百分比。默认是45%，如果老年代占用增长快，可能需要降低这个值，让G1更早开始并发标记，避免堆被占满。")]),e._v(" "),a("p",[e._v("例如:"),a("code",[e._v("-XX:InitiatingHeapOccupancyPercent=35")]),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"控制晋升到老年代的gc次数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#控制晋升到老年代的gc次数"}},[e._v("#")]),e._v(" 控制晋升到老年代的GC次数")]),e._v(" "),a("p",[e._v("通过"),a("code",[e._v("-XX:MaxTenuringThreshold")]),e._v("和"),a("code",[e._v("-XX:TargetSurvivorRatio")]),e._v("设置，例如:"),a("code",[e._v("-XX:MaxTenuringThreshold=20")]),e._v("和"),a("code",[e._v("-XX:TargetSurvivorRatio=80")]),e._v("，默认是15和80%，即对象晋升到老年代的次数达到15次或者"),a("code",[e._v("Survivor")]),e._v("区的存活对象占比超过80%时，会晋升到老年代。")]),e._v(" "),a("h3",{attrs:{id:"控制g1的mixed-gc的阈值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#控制g1的mixed-gc的阈值"}},[e._v("#")]),e._v(" 控制"),a("code",[e._v("G1")]),e._v("的"),a("code",[e._v("Mixed GC")]),e._v("的阈值")]),e._v(" "),a("p",[a("code",[e._v("Mixed GC")]),e._v("是指在"),a("code",[e._v("Young GC")]),e._v("和"),a("code",[e._v("Full GC")]),e._v("之间的一种混合模式，通过"),a("code",[e._v("-XX:G1MixedGCLiveThresholdPercent")]),e._v("设置，例如:"),a("code",[e._v("-XX:G1MixedGCLiveThresholdPercent=65")]),e._v("，默认是65%，即当"),a("code",[e._v("Region")]),e._v("中存活对象占比超过65%时，会触发"),a("code",[e._v("Mixed GC")]),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"控制g1的full-gc的阈值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#控制g1的full-gc的阈值"}},[e._v("#")]),e._v(" 控制"),a("code",[e._v("G1")]),e._v("的"),a("code",[e._v("Full GC")]),e._v("的阈值")]),e._v(" "),a("p",[e._v("通过"),a("code",[e._v("-XX:InitiatingHeapOccupancyPercent")]),e._v("设置，例如:"),a("code",[e._v("-XX:InitiatingHeapOccupancyPercent=45")]),e._v("，默认是45%，即当堆占用达到45%时，会触发"),a("code",[e._v("Full GC")]),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"调整metaspace大小"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调整metaspace大小"}},[e._v("#")]),e._v(" 调整Metaspace大小")]),e._v(" "),a("p",[a("code",[e._v("G1")]),e._v("使用"),a("code",[e._v("Metaspace")]),e._v("来存储类元数据，可以通过"),a("code",[e._v("-XX:MetaspaceSize")]),e._v("和"),a("code",[e._v("-XX:MaxMetaspaceSize")]),e._v("设置"),a("code",[e._v("Metaspace")]),e._v("的大小。")]),e._v(" "),a("h3",{attrs:{id:"限制年轻代动态扩容范围"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#限制年轻代动态扩容范围"}},[e._v("#")]),e._v(" 限制年轻代动态扩容范围")]),e._v(" "),a("p",[e._v("通过"),a("code",[e._v("-XX:G1NewSizePercent")]),e._v("和"),a("code",[e._v("-XX:G1MaxNewSizePercent")]),e._v("设置，例如:"),a("code",[e._v("-XX:G1NewSizePercent=20")]),e._v("和"),a("code",[e._v("-XX:G1MaxNewSizePercent=60")]),e._v("，默认是5%和60%，即年轻代的大小在5%~60%之间动态调整。")]),e._v(" "),a("h3",{attrs:{id:"调整堆扩展的激进程度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调整堆扩展的激进程度"}},[e._v("#")]),e._v(" 调整堆扩展的激进程度")]),e._v(" "),a("p",[e._v("G1倾向于快速扩展堆以满足分配需求，通过调整"),a("code",[e._v("-XX:MinHeapFreeRatio")]),e._v("和"),a("code",[e._v("-XX:MaxHeapFreeRatio")]),e._v("控制扩展阈值：")]),e._v(" "),a("div",{staticClass:"language-BASH line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 当空闲堆内存低于20%时扩展（默认40%）")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[e._v("-XX:MinHeapFreeRatio")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("20")]),e._v("  \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 当空闲堆内存高于50%时收缩（默认70%）")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[e._v("-XX:MaxHeapFreeRatio")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("50")]),e._v("  \n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])])])}),[],!1,null,null,null);a.default=_.exports}}]);