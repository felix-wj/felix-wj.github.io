(window.webpackJsonp=window.webpackJsonp||[]).push([[163],{631:function(t,a,v){"use strict";v.r(a);var _=v(10),r=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"设计模式分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计模式分类"}},[t._v("#")]),t._v(" 设计模式分类")]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/design-patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.png",alt:"组件的生命周期"}})]),t._v(" "),a("h3",{attrs:{id:"结构型模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结构型模式"}},[t._v("#")]),t._v(" 结构型模式")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("适配器模式 adapter pattern")]),t._v(" "),a("p",[t._v("连接两个类，使一个类可以使用另一个类的功能")])]),t._v(" "),a("li",[a("p",[t._v("桥接模式 bridge pattern\nInputStreamReader")])]),t._v(" "),a("li",[a("p",[t._v("过滤器模式 filter、criteria pattern")])]),t._v(" "),a("li",[a("p",[t._v("组合模式 composite pattern")])]),t._v(" "),a("li",[a("p",[t._v("装饰器模式 decorator/wrapper pattern")])]),t._v(" "),a("li",[a("p",[t._v("外观模式 facade pattern")])]),t._v(" "),a("li",[a("p",[t._v("享元模式 flyweight pattern")])]),t._v(" "),a("li",[a("p",[t._v("代理模式 proxy pattern")])])]),t._v(" "),a("h3",{attrs:{id:"创建型模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建型模式"}},[t._v("#")]),t._v(" 创建型模式")]),t._v(" "),a("p",[t._v("将对象的创建与使用分离，降低系统的耦合度。使用者无需关注对象的创建细节。")]),t._v(" "),a("ul",[a("li",[t._v("单例 singleton")]),t._v(" "),a("li",[t._v("原形 prototype")]),t._v(" "),a("li",[t._v("工厂方法 factory method")]),t._v(" "),a("li",[t._v("抽象工厂 abstract factory method")]),t._v(" "),a("li",[t._v("建造者 builder")])]),t._v(" "),a("h3",{attrs:{id:"行为型模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#行为型模式"}},[t._v("#")]),t._v(" 行为型模式")]),t._v(" "),a("ul",[a("li",[t._v("模板模式 template\n定义一套流程，具体方法实现留给子类")]),t._v(" "),a("li",[t._v("策略模式 strategy")]),t._v(" "),a("li",[t._v("状态模式 state")]),t._v(" "),a("li",[t._v("终结者模式 mediator")]),t._v(" "),a("li",[t._v("观察者模式 observer")]),t._v(" "),a("li",[t._v("备忘录模式 memento")]),t._v(" "),a("li",[t._v("解释器 interpreter")]),t._v(" "),a("li",[t._v("命令模式 command")]),t._v(" "),a("li",[t._v("迭代器模式 iterator")]),t._v(" "),a("li",[t._v("访问者模式 visitor")]),t._v(" "),a("li",[t._v("责任链模式 chain of responsibility")])]),t._v(" "),a("h2",{attrs:{id:"七大原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七大原则"}},[t._v("#")]),t._v(" 七大原则")]),t._v(" "),a("h3",{attrs:{id:"开闭原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开闭原则"}},[t._v("#")]),t._v(" 开闭原则")]),t._v(" "),a("p",[t._v("对扩展开放，对修改关闭。")]),t._v(" "),a("p",[t._v("扩展新类，而不是修改旧类。")]),t._v(" "),a("h3",{attrs:{id:"里式替换原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#里式替换原则"}},[t._v("#")]),t._v(" 里式替换原则")]),t._v(" "),a("p",[t._v("继承必须确保超类所拥有的的性质在子类中任成立。")]),t._v(" "),a("p",[t._v("继承父类而不是改变父类。")]),t._v(" "),a("h3",{attrs:{id:"依赖倒置原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒置原则"}},[t._v("#")]),t._v(" 依赖倒置原则")]),t._v(" "),a("p",[t._v("高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。")]),t._v(" "),a("p",[t._v("面向接口编程，而不是面向实现类。")]),t._v(" "),a("h3",{attrs:{id:"单一职责原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则"}},[t._v("#")]),t._v(" 单一职责原则")]),t._v(" "),a("p",[t._v("一个类应该有且只有一个引起变化的原因，否则类应该被拆分。")]),t._v(" "),a("p",[t._v("每个类只负责自己的事情，而不是变成万能。")]),t._v(" "),a("h3",{attrs:{id:"接口隔离原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则"}},[t._v("#")]),t._v(" 接口隔离原则")]),t._v(" "),a("p",[t._v("一个类对另一个类的依赖应该建立在最小接口上。")]),t._v(" "),a("p",[t._v("各个类建立自己的专用接口，而不是建立万能接口。")]),t._v(" "),a("h3",{attrs:{id:"迪米特法则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#迪米特法则"}},[t._v("#")]),t._v(" 迪米特法则")]),t._v(" "),a("p",[t._v("最少知道原则。")]),t._v(" "),a("p",[t._v("只与你的直接朋友交谈，不跟陌生人说话。")]),t._v(" "),a("p",[t._v("无需直接交互的两个类，如果需要交互，使用中间者。")]),t._v(" "),a("h3",{attrs:{id:"合成复用原则-组合复用原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合成复用原则-组合复用原则"}},[t._v("#")]),t._v(" 合成复用原则  组合复用原则")]),t._v(" "),a("p",[t._v("优先使用组合其次继承")])])}),[],!1,null,null,null);a.default=r.exports}}]);